/*
 * drivers/media/i2c/soc_camera/xgold/ov5648.c
 *
 * ov5648 sensor driver
 *
 * Copyright (C) 2012-2014 Intel Mobile Communications GmbH
 *
 * Copyright (C) 2008 Texas Instruments.
 *
 * This file is licensed under the terms of the GNU General Public License
 * version 2. This program is licensed "as is" without any warranty of any
 * kind, whether express or implied.
 *
 * Note:
 *    11/14/2014: new implementation using v4l2-subdev
 *                        instead of v4l2-int-device.
 */

#include <linux/i2c.h>
#include <linux/io.h>
#include <linux/delay.h>
#include <linux/module.h>
#include <media/v4l2-subdev.h>
#include <media/videobuf-core.h>
#include <linux/slab.h>
#include "ov_camera_module.h"

#define OV5648_DRIVER_NAME "ov5648"
/*
#define OV5648_G_TIMINGS_QUICK
*/
#define OV5648_EXT_CLK 26000000

#define OV5648_FETCH_LSB_GAIN(VAL) (VAL & 0x00FF)
#define OV5648_FETCH_MSB_GAIN(VAL) ((VAL >> 8) & 0x7)

#define OV5648_AEC_PK_LONG_GAIN_HIGH_REG       0x350a	/* Bit 8 */
#define OV5648_AEC_PK_LONG_GAIN_LOW_REG	       0x350b	/* Bits 0 -7 */

#define OV5648_AEC_PK_LONG_EXPO_3RD_REG        0x3500	/* Exposure Bits 16-19 */
#define OV5648_AEC_PK_LONG_EXPO_2ND_REG        0x3501	/* Exposure Bits 8-15 */
#define OV5648_AEC_PK_LONG_EXPO_1ST_REG        0x3502	/* Exposure Bits 0-7 */

#define OV5648_AEC_GROUP_UPDATE_ADDRESS        0x3208
#define OV5648_AEC_GROUP_UPDATE_START_DATA     0x00
#define OV5648_AEC_GROUP_UPDATE_END_DATA       0x10
#define OV5648_AEC_GROUP_UPDATE_END_LAUNCH     0xA0

#define OV5648_FETCH_3RD_BYTE_EXP(VAL) ((VAL >> 16) & 0xF)	/* 4 Bits */
#define OV5648_FETCH_2ND_BYTE_EXP(VAL) ((VAL >> 8) & 0xFF)	/* 8 Bits */
#define OV5648_FETCH_1ST_BYTE_EXP(VAL) (VAL & 0xFF)	/* 8 Bits */

#define OV5648_PIDH_ADDR                       0x300A
#define OV5648_PIDL_ADDR                       0x300B

#define OV5648_TIMING_HTS_HIGH_REG             0x380c
#define OV5648_TIMING_HTS_LOW_REG              0x380d
#define OV5648_TIMING_VTS_HIGH_REG             0x380e
#define OV5648_TIMING_VTS_LOW_REG              0x380f

#define OV5648_INTEGRATION_TIME_MARGIN         4

#define OV5648_TIMING_X_INC		               0x3814
#define OV5648_TIMING_Y_INC		               0x3815

#define OV5648_HORIZONTAL_START_HIGH_REG       0x3800
#define OV5648_HORIZONTAL_START_LOW_REG        0x3801
#define OV5648_VERTICAL_START_HIGH_REG         0x3802
#define OV5648_VERTICAL_START_LOW_REG          0x3803
#define OV5648_HORIZONTAL_END_HIGH_REG         0x3804
#define OV5648_HORIZONTAL_END_LOW_REG          0x3805
#define OV5648_VERTICAL_END_HIGH_REG           0x3806
#define OV5648_VERTICAL_END_LOW_REG            0x3807
#define OV5648_HORIZONTAL_OUTPUT_SIZE_HIGH_REG 0x3808
#define OV5648_HORIZONTAL_OUTPUT_SIZE_LOW_REG  0x3809
#define OV5648_VERTICAL_OUTPUT_SIZE_HIGH_REG   0x380a
#define OV5648_VERTICAL_OUTPUT_SIZE_LOW_REG    0x380b

#define OV5648_MIPI_BITMODE_REG                0x3034
#define OV5648_PLL_SYSDIV_REG                  0x3035
#define OV5648_PLL_MULTIPLIER_REG              0x3036
#define OV5648_PLL_PREDIV_REG                  0x3037
#define OV5648_PLL_CLKDIV_REG                  0x3106

#define OV5648_H_WIN_OFF_HIGH_REG              0x3810
#define OV5648_H_WIN_OFF_LOW_REG               0x3811
#define OV5648_V_WIN_OFF_HIGH_REG              0x3812
#define OV5648_V_WIN_OFF_LOW_REG               0x3813

/* High byte of product ID */
#define OV5648_PIDH_MAGIC 0x56
/* Low byte of product ID  */
#define OV5648_PIDL_MAGIC 0x48

static struct ov_camera_module ov5648;

#define BG_Ratio_Typical  0x163
#define RG_Ratio_Typical  0x17c

#define OV5648_FLIP 0x16
#define OV5648_MIRROR 0x6

#define OV5648_FLIP_REG                      0x3820
#define OV5648_MIRROR_REG                      0x3821

struct ov5648_otp_struct {
		int otp_en;
		int flag;
		u32 module_integrator_id;
		u32 lens_id;
		u32 rg_ratio;
		u32 bg_ratio;
		u32 user_data[2];
		u32 light_rg;
		u32 light_bg;
		int R_gain;
		int G_gain;
		int B_gain;
};

static struct ov5648_otp_struct *otp_ptr;

/* ======================================================================== */
/* Base sensor configs */
/* ======================================================================== */

/* ======================================================================== */
#if 0
static const struct ov_camera_module_reg ov5648_init_tab_1296_864_30fps_vfifo[] = {
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x0103, 0x01},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3001, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3002, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3011, 0x02},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3017, 0x05},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3018, 0x4c},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x301c, 0xd2},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3022, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3034, 0x1a},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3035, 0x21},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3036, 0x69},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3037, 0x03},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3038, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3039, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x303a, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x303b, 0x19},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x303c, 0x11},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x303d, 0x30},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3105, 0x11},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3106, 0x05},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3304, 0x28},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3305, 0x41},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3306, 0x30},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3308, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3309, 0xc8},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x330a, 0x01},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x330b, 0x90},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x330c, 0x02},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x330d, 0x58},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x330e, 0x03},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x330f, 0x20},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3300, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3500, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3501, 0x7b},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3502, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3503, 0x07},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x350a, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x350b, 0x40},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3601, 0x33},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3602, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3611, 0x0e},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3612, 0x2b},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3614, 0x50},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3620, 0x33},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3622, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3630, 0xad},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3631, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3632, 0x94},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3633, 0x17},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3634, 0x14},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3704, 0xc0},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3705, 0x2a},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3708, 0x63},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3709, 0x12},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x370b, 0x23},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x370c, 0xc0},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x370d, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x370e, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x371c, 0x07},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3739, 0xd2},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x373c, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3800, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3801, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3802, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3803, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3804, 0x0a},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3805, 0x3f},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3806, 0x07},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3807, 0xa3},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3808, 0x0a},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3809, 0x20},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380a, 0x07},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380b, 0x98},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380c, 0x0b},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380d, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380e, 0x07},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380f, 0xc0},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3810, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3811, 0x10},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3812, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3813, 0x06},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3814, 0x11},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3815, 0x11},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3817, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3820, 0x40},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3821, 0x06},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3826, 0x03},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3829, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x382b, 0x0b},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3830, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3836, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3837, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3838, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3839, 0x04},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x383a, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x383b, 0x01},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b00, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b02, 0x08},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b03, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b04, 0x04},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b05, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b06, 0x04},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b07, 0x08},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b08, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b09, 0x02},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b0a, 0x04},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b0b, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b0c, 0x3d},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3f01, 0x0d},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3f0f, 0xf5},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4000, 0x89},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4001, 0x02},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4002, 0x45},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4004, 0x04},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4005, 0x18},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4006, 0x08},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4007, 0x10},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4008, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4050, 0x6e},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4051, 0x8f},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4300, 0xf8},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4303, 0xff},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4304, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4307, 0xff},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4520, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4521, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4511, 0x22},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4801, 0x0f},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4814, 0x2a},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x481f, 0x3c},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4823, 0x3c},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4826, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x481b, 0x3c},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4827, 0x32},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4837, 0x18},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4b00, 0x06},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4b01, 0x0a},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4b04, 0x10},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5000, 0xff},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5001, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5002, 0x41},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5003, 0x0a},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5004, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5043, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5013, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x501f, 0x03},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x503d, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5a00, 0x08},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5b00, 0x01},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5b01, 0x40},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5b02, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5b03, 0xf0},

	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3708, 0x66},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3709, 0x52},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x370c, 0xcf},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3800, 0x00}, /* xstart = 0 */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3801, 0x00}, /* xstart ;10 */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3802, 0x00}, /* ystart = 98 */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3803, 0x62}, /* ystart */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3804, 0x0a}, /* xend = 2607 */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3805, 0x2f}, /* xend */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3806, 0x07}, /* yend = 1845 */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3807, 0x35}, /* yend */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3808, 0x05}, /* x output size = 1296 */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3809, 0x10}, /*;x output size */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380a, 0x03}, /* y output size = 864 */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380b, 0x60}, /*;y output size */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380c, 0x09}, /* hts = 1864 ;2400 */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380d, 0x60}, /* hts48 */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380e, 0x04}, /* vts = 754; 1120 */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380f, 0x60}, /* vts f2 */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3810, 0x00}, /* isp x win (offset)= 0 */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3811, 0x00}, /* isp x win;08 */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3812, 0x00}, /* isp y win (offset)= 0 */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3813, 0x00}, /* isp y win;02 */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3814, 0x31}, /* x inc */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3815, 0x31}, /* y inc */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3817, 0x00}, /* hsync start */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3820, 0x08}, /* flip off; v bin off */
	/*{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3821, 0x01}, //mirror off; h bin on */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4004, 0x02}, /* black line number */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4005, 0x18}, /* blc level trigger */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4837, 0x18}, /* MIPI global timing ;2f;18 */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x350b, 0x80}, /* gain 8x */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3501, 0x35}, /* exposure */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3502, 0xc0}, /* exposure */	/*;add 19.2MHz 30fps*/

	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3034, 0x1a}, /* mipi 10bit mode */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3035, 0x21},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3036, 0x3f}, /*41;  0x58;*/
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3037, 0x02},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3038, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3039, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3106, 0x05},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3105, 0x11},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x303a, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x303b, 0x10}, /*0x16;*/
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x303c, 0x11},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x303d, 0x20},
};

static const struct ov_camera_module_reg ov5648_init_tab_1304_976_30fps_vfifo[] = {
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x0103, 0x01},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3001, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3002, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3011, 0x02},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3017, 0x05},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3018, 0x4c},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x301c, 0xd2},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3022, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3034, 0x1a},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3035, 0x21},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3036, 0x69},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3037, 0x03},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3038, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3039, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x303a, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x303b, 0x19},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x303c, 0x11},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x303d, 0x30},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3105, 0x11},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3106, 0x05},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3304, 0x28},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3305, 0x41},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3306, 0x30},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3308, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3309, 0xc8},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x330a, 0x01},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x330b, 0x90},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x330c, 0x02},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x330d, 0x58},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x330e, 0x03},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x330f, 0x20},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3300, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3500, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3501, 0x7b},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3502, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3503, 0x07},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x350a, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x350b, 0x40},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3601, 0x33},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3602, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3611, 0x0e},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3612, 0x2b},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3614, 0x50},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3620, 0x33},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3622, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3630, 0xad},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3631, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3632, 0x94},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3633, 0x17},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3634, 0x14},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3704, 0xc0},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3705, 0x2a},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3708, 0x63},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3709, 0x12},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x370b, 0x23},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x370c, 0xc0},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x370d, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x370e, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x371c, 0x07},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3739, 0xd2},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x373c, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3800, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3801, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3802, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3803, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3804, 0x0a},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3805, 0x3f},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3806, 0x07},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3807, 0xa3},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3808, 0x0a},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3809, 0x20},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380a, 0x07},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380b, 0x98},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380c, 0x0b},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380d, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380e, 0x07},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380f, 0xc0},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3810, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3811, 0x10},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3812, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3813, 0x06},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3814, 0x11},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3815, 0x11},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3817, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3820, 0x40},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3821, 0x06},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3826, 0x03},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3829, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x382b, 0x0b},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3830, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3836, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3837, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3838, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3839, 0x04},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x383a, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x383b, 0x01},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b00, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b02, 0x08},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b03, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b04, 0x04},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b05, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b06, 0x04},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b07, 0x08},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b08, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b09, 0x02},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b0a, 0x04},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b0b, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b0c, 0x3d},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3f01, 0x0d},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3f0f, 0xf5},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4000, 0x89},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4001, 0x02},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4002, 0x45},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4004, 0x04},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4005, 0x18},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4006, 0x08},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4007, 0x10},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4008, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4050, 0x6e},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4051, 0x8f},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4300, 0xf8},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4303, 0xff},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4304, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4307, 0xff},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4520, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4521, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4511, 0x22},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4801, 0x0f},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4814, 0x2a},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x481f, 0x3c},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4823, 0x3c},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4826, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x481b, 0x3c},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4827, 0x32},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4837, 0x18},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4b00, 0x06},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4b01, 0x0a},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4b04, 0x10},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5000, 0xff},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5001, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5002, 0x41},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5003, 0x0a},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5004, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5043, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5013, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x501f, 0x03},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x503d, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5a00, 0x08},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5b00, 0x01},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5b01, 0x40},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5b02, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5b03, 0xf0},

	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3708, 0x66},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3709, 0x52},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x370c, 0xcf},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3800, 0x00}, /* xstart = 0 */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3801, 0x00}, /* xstart ;10 */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3802, 0x00}, /* ystart = 0 */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3803, 0x00}, /* ystart */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3804, 0x0a}, /* xend = 2623 */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3805, 0x3f}, /* xend */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3806, 0x07}, /* yend = 1955 */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3807, 0xa3}, /* yend */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3808, 0x05}, /* x output size = 1304 */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3809, 0x18}, /*;x output size */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380a, 0x03}, /* y output size = 976 */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380b, 0xd0}, /*;y output size */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380c, 0x09}, /* hts = 2400 */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380d, 0x60}, /* hts */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380e, 0x04}, /* vts = 1120 */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380f, 0x60}, /* vts */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3810, 0x00}, /* isp x win (offset)= 4 */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3811, 0x04}, /* isp x win; */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3812, 0x00}, /* isp y win (offset)= 0 */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3813, 0x00}, /* isp y win; */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3814, 0x31}, /* x inc */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3815, 0x31}, /* y inc */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3817, 0x00}, /* hsync start */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3820, 0x08}, /* flip off; v bin off */
	/*{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3821, 0x01}, // mirror off; h bin on */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4004, 0x02}, /* black line number */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4005, 0x18}, /* blc level trigger */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4837, 0x18}, /* MIPI global timing ;2f;18 */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x350b, 0x40}, /* gain 4x */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3501, 0x35}, /* exposure */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3502, 0xc0}, /* exposure */	/*add 19.2MHz 30fps */


	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3034, 0x1a}, /* mipi 10bit mode */
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3035, 0x21},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3036, 0x3f},  /*0x58;*/
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3037, 0x02},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3038, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3039, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3106, 0x05},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3105, 0x11},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x303a, 0x00},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x303b, 0x10}, /*0x16;*/
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x303c, 0x11},
	{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x303d, 0x20},
};
#endif
static const struct ov_camera_module_reg ov5648_init_tab_1296_972_30fps_vfifo[] = {
/*  sckl=81.9Mhz pll_adclk=208M */
/*  mipi bitrate=409.5Mbps/lane */
/*  2lane 10bit */
/*  1296x972 4:3 binning 30fps */
/*  HTS=2400,vts=1136  */
/*  vblanking=11.72ms  */
/*  based on OV5648R1A_AM05e.ovd on 2015/06/18 */

{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x0103, 0x01},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x301a, 0xf1},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3001, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3002, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3011, 0x02},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3017, 0x05},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3018, 0x4c},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x301c, 0xd2},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3022, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3034, 0x1a},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3035, 0x21},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3036, 0x3f},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3037, 0x02},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3038, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3039, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x303a, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x303b, 0x10},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x303c, 0x11},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x303d, 0x20},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3106, 0x05},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3105, 0x11},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3304, 0x28},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3305, 0x41},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3306, 0x30},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3308, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3309, 0xc8},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x330a, 0x01},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x330b, 0x90},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x330c, 0x02},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x330d, 0x58},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x330e, 0x03},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x330f, 0x20},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3300, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3500, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3501, 0x7b},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3502, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3503, 0x07},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x350a, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x350b, 0x40},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3601, 0x33},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3602, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3611, 0x0e},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3612, 0x2b},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3614, 0x50},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3620, 0x33},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3622, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3630, 0xad},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3631, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3632, 0x94},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3633, 0x17},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3634, 0x14},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3704, 0xc0},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3705, 0x2a},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3708, 0x66},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3709, 0x52},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x370b, 0x23},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x370c, 0xcf},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x370d, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x370e, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x371c, 0x07},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3739, 0xd2},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x373c, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3800, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3801, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3802, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3803, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3804, 0x0a},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3805, 0x3f},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3806, 0x07},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3807, 0xa3},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3808, 0x05},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3809, 0x10},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380a, 0x03},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380b, 0xcc},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380c, 0x09},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380d, 0x60},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380e, 0x04},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380f, 0x70},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3810, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3811, 0x08},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3812, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3813, 0x04},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3814, 0x31},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3815, 0x31},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3817, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3820, 0x08},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3821, 0x07},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3826, 0x03},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3829, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x382b, 0x0b},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3830, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3836, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3837, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3838, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3839, 0x04},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x383a, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x383b, 0x01},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b00, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b02, 0x08},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b03, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b04, 0x04},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b05, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b06, 0x04},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b07, 0x08},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b08, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b09, 0x02},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b0a, 0x04},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b0b, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b0c, 0x3d},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3f01, 0x0d},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3f0f, 0xf5},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4000, 0x89},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4001, 0x02},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4002, 0x45},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4004, 0x02},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4005, 0x18},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4006, 0x08},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4007, 0x10},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4008, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4050, 0x6e},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4051, 0x8f},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4300, 0xf8},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4303, 0xff},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4304, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4307, 0xff},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4520, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4521, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4511, 0x22},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4801, 0x0f},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4814, 0x2a},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x481f, 0x3c},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4823, 0x3c},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4826, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x481b, 0x3c},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4827, 0x32},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4837, 0x18},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4b00, 0x06},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4b01, 0x0a},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4b04, 0x10},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5000, 0xff},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5001, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5002, 0x41},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5003, 0x0a},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5004, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5043, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5013, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x501f, 0x03},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x503d, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5780, 0xfc},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5781, 0x1f},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5782, 0x03},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5786, 0x20},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5787, 0x40},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5788, 0x08},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5789, 0x08},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x578a, 0x02},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x578b, 0x01},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x578c, 0x01},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x578d, 0x0c},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x578e, 0x02},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x578f, 0x01},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5790, 0x01},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5a00, 0x08},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5b00, 0x01},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5b01, 0x40},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5b02, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5b03, 0xf0},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4800, 0x24},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x0100, 0x01},
};
static const struct ov_camera_module_reg ov5648_init_tab_1280_720_30fps_vfifo[] = {
/*  sckl=81.9Mhz pll_adclk=208M */
/*  mipi bitrate=409.5Mbps/lane */
/*  2lane 10bit */
/*  1296x736 16:9 binning 30fps */
/*  HTS=2400,vts=1136  */
/*  vblanking=11.72ms  */
/*  based on OV5648R1A_AM05e.ovd on 2015/06/18 */
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x0103, 0x01},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x301a, 0xf1},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3001, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3002, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3011, 0x02},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3017, 0x05},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3018, 0x4c},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x301c, 0xd2},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3022, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3034, 0x1a},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3035, 0x21},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3036, 0x69},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3037, 0x03},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3038, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3039, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x303a, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x303b, 0x19},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x303c, 0x11},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x303d, 0x30},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3105, 0x11},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3106, 0x05},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3304, 0x28},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3305, 0x41},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3306, 0x30},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3308, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3309, 0xc8},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x330a, 0x01},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x330b, 0x90},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x330c, 0x02},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x330d, 0x58},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x330e, 0x03},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x330f, 0x20},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3300, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3500, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3501, 0x7b},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3502, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3503, 0x07},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x350a, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x350b, 0x40},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3601, 0x33},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3602, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3611, 0x0e},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3612, 0x2b},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3614, 0x50},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3620, 0x33},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3622, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3630, 0xad},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3631, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3632, 0x94},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3633, 0x17},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3634, 0x14},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3704, 0xc0},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3705, 0x2a},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3708, 0x63},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3709, 0x12},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x370b, 0x23},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x370c, 0xc0},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x370d, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x370e, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x371c, 0x07},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3739, 0xd2},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x373c, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3800, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3801, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3802, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3803, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3804, 0x0a},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3805, 0x3f},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3806, 0x07},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3807, 0xa3},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3808, 0x0a},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3809, 0x20},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380a, 0x07},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380b, 0x98},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380c, 0x0b},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380d, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380e, 0x07},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380f, 0xc0},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3810, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3811, 0x10},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3812, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3813, 0x06},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3814, 0x11},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3815, 0x11},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3817, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3820, 0x40},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3821, 0x06},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3826, 0x03},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3829, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x382b, 0x0b},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3830, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3836, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3837, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3838, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3839, 0x04},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x383a, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x383b, 0x01},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b00, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b02, 0x08},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b03, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b04, 0x04},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b05, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b06, 0x04},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b07, 0x08},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b08, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b09, 0x02},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b0a, 0x04},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b0b, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b0c, 0x3d},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3f01, 0x0d},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3f0f, 0xf5},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4000, 0x89},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4001, 0x02},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4002, 0x45},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4004, 0x04},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4005, 0x18},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4006, 0x08},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4007, 0x10},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4008, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4050, 0x6e},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4051, 0x8f},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4300, 0xf8},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4303, 0xff},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4304, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4307, 0xff},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4520, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4521, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4511, 0x22},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4801, 0x0f},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4814, 0x2a},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x481f, 0x3c},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4823, 0x3c},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4826, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x481b, 0x3c},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4827, 0x32},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4837, 0x18},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4b00, 0x06},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4b01, 0x0a},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4b04, 0x10},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5000, 0xff},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5001, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5002, 0x41},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5003, 0x0a},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5004, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5043, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5013, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x501f, 0x03},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x503d, 0x00},

{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5a00, 0x08},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5b00, 0x01},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5b01, 0x40},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5b02, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5b03, 0xf0},

{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3708, 0x66},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3709, 0x52},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x370c, 0xcf},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3800, 0x00}, /* xstart = 0 */
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3801, 0x10}, /*;xstart10 */
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3802, 0x00}, /* ystart = 226 */
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3803, 0xfe}, /* ystart ;fe */
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3804, 0x0a}, /* xend = 2607 */
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3805, 0x2f}, /* xend */
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3806, 0x06}, /* yend = 1701 */
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3807, 0xa5}, /* yend */
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3808, 0x05}, /* x output size = 1280 */
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3809, 0x00}, /*;x output size 00 */
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380a, 0x02}, /* y output size = 720 */
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380b, 0xd0}, /*;y output size d0 */
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380c, 0x09}, /* hts = 1864  2400 */
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380d, 0x60}, /* hts 48 */
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380e, 0x04}, /* vts = 754; 1120 */
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380f, 0x70}, /* vts f2 */
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3810, 0x00}, /* isp x win (offset)= 0 */
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3811, 0x08}, /* isp x win;08 */
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3812, 0x00}, /* isp y win (offset)= 0 */
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3813, 0x02}, /* isp y win;02 */
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3814, 0x31}, /* x inc */
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3815, 0x31}, /* y inc */
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3817, 0x00}, /* hsync start */
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3820, 0x08}, /* flip off; v bin off */
/* {OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3821, 0x01}, // mirror off; h bin on  */
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4004, 0x02}, /* black line number */
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4005, 0x18}, /* blc level trigger */
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4837, 0x18}, /* MIPI global timing ;2f;18 */
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x350b, 0x80}, /* gain 8x */
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3501, 0x2d}, /* exposure */
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3502, 0xc0}, /* exposure */	/*;add 19.2MHz 30fps */
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5780, 0xfc},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5781, 0x1f},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5782, 0x03},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5786, 0x20},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5787, 0x40},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5788, 0x08},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5789, 0x08},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x578a, 0x02},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x578b, 0x01},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x578c, 0x01},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x578d, 0x0c},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x578e, 0x02},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x578f, 0x01},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5790, 0x01},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3034, 0x1a}, /* mipi 10bit mode */
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3035, 0x21},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3036, 0x3f}, /* 41;  0x58; */
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3037, 0x02},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3038, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3039, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3106, 0x05},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3105, 0x11},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x303a, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x303b, 0x10}, /* 0x16 */
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x303c, 0x11},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x303d, 0x20},

{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4800, 0x24},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x0100, 0x01},
};

static const struct ov_camera_module_reg ov5648_init_tab_2592_1944_15fps_vfifo[] = {
/* sckl=87.5333Mhz pll_daclk=216.6M */
/* mipi bitrate=437.667Mbps/lane */
/* 2lane 10bit */
/* 2592x1944 4:3 max fov 15fps */
/* HTS=2816,vts=2072 */
/* vblanking=4.11ms */
/*  based on OV5648R1A_AM05e.ovd on 2015/06/18 */
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x0103, 0x01},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x301a, 0xf1},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3001, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3002, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3011, 0x02},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3017, 0x05},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3018, 0x4c},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x301c, 0xd2},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3022, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3034, 0x1a},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3035, 0x21},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3036, 0x65},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3037, 0x03},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3038, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3039, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x303a, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x303b, 0x19},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x303c, 0x11},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x303d, 0x30},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3105, 0x11},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3106, 0x05},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3304, 0x28},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3305, 0x41},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3306, 0x30},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3308, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3309, 0xc8},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x330a, 0x01},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x330b, 0x90},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x330c, 0x02},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x330d, 0x58},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x330e, 0x03},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x330f, 0x20},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3300, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3500, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3501, 0x7b},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3502, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3503, 0x07},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x350a, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x350b, 0x40},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3601, 0x33},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3602, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3611, 0x0e},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3612, 0x2b},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3614, 0x50},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3620, 0x33},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3622, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3630, 0xad},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3631, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3632, 0x94},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3633, 0x17},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3634, 0x14},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3704, 0xc0},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3705, 0x2a},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3708, 0x63},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3709, 0x12},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x370b, 0x23},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x370c, 0xcc},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x370d, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x370e, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x371c, 0x07},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3739, 0xd2},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x373c, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3800, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3801, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3802, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3803, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3804, 0x0a},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3805, 0x3f},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3806, 0x07},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3807, 0xa3},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3808, 0x0a},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3809, 0x20},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380a, 0x07},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380b, 0x98},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380c, 0x0b},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380d, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380e, 0x08},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x380f, 0x18},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3810, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3811, 0x10},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3812, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3813, 0x06},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3814, 0x11},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3815, 0x11},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3817, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3820, 0x40},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3821, 0x06},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3826, 0x03},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3829, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x382b, 0x0b},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3830, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3836, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3837, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3838, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3839, 0x04},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x383a, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x383b, 0x01},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b00, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b02, 0x08},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b03, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b04, 0x04},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b05, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b06, 0x04},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b07, 0x08},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b08, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b09, 0x02},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b0a, 0x04},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b0b, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3b0c, 0x3d},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3f01, 0x0d},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x3f0f, 0xf5},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4000, 0x89},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4001, 0x02},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4002, 0x45},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4004, 0x04},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4005, 0x18},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4006, 0x08},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4007, 0x10},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4008, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4050, 0x6e},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4051, 0x8f},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4300, 0xf8},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4303, 0xff},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4304, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4307, 0xff},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4520, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4521, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4511, 0x22},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4801, 0x0f},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4814, 0x2a},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x481f, 0x3c},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4823, 0x3c},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4826, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x481b, 0x3c},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4827, 0x32},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4837, 0x18}, /* 0x18 -> 0x2f; */
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4b00, 0x06},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4b01, 0x0a},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4b04, 0x10},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5000, 0xff},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5001, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5002, 0x41},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5003, 0x0a},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5004, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5043, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5013, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x501f, 0x03},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x503d, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5780, 0xfc},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5781, 0x1f},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5782, 0x03},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5786, 0x20},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5787, 0x40},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5788, 0x08},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5789, 0x08},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x578a, 0x02},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x578b, 0x01},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x578c, 0x01},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x578d, 0x0c},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x578e, 0x02},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x578f, 0x01},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5790, 0x01},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5a00, 0x08},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5b00, 0x01},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5b01, 0x40},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5b02, 0x00},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x5b03, 0xf0},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x4800, 0x24},
{OV_CAMERA_MODULE_REG_TYPE_DATA, 0x0100, 0x01},
};

static struct ov_camera_module_config ov5648_configs[] = {
	{
		.name    = "1296x972_30fps",
		.frm_fmt = {
			.width  = 1296,
			.height = 972,
			.code   = V4L2_MBUS_FMT_SBGGR10_1X10
		},
		.frm_intrvl = {
			.interval = {
				.numerator     = 1,
				.denominator   = 30
			}
		},
		.auto_exp_enabled      = false,
		.auto_gain_enabled     = false,
		.auto_wb_enabled       = false,
		.reg_table             = (void *)ov5648_init_tab_1296_972_30fps_vfifo,
		.reg_table_num_entries =
			sizeof(ov5648_init_tab_1296_972_30fps_vfifo)
			/
			sizeof(ov5648_init_tab_1296_972_30fps_vfifo[0]),
		.v_blanking_time_us    = 11720
	},
	{
		.name    = "1280x720_30fps",
		.frm_fmt = {
			.width  = 1280,
			.height = 720,
			.code   = V4L2_MBUS_FMT_SBGGR10_1X10
		},
		.frm_intrvl = {
			.interval = {
				.numerator     = 1,
				.denominator   = 30
			}
		},
		.auto_exp_enabled      = false,
		.auto_gain_enabled     = false,
		.auto_wb_enabled       = false,
		.reg_table             = (void *)ov5648_init_tab_1280_720_30fps_vfifo,
		.reg_table_num_entries =
			sizeof(ov5648_init_tab_1280_720_30fps_vfifo)
			/
			sizeof(ov5648_init_tab_1280_720_30fps_vfifo[0]),
		.v_blanking_time_us    = 11400
	},

	{
		.name    = "2592x1944_15fps",
		.frm_fmt = {
			.width  = 2592,
			.height = 1944,
			.code   = V4L2_MBUS_FMT_SBGGR10_1X10
		},
		.frm_intrvl = {
			.interval = {
				.numerator     = 1,
				.denominator   = 15
			}
		},
		.auto_exp_enabled      = false,
		.auto_gain_enabled     = false,
		.auto_wb_enabled       = false,
		.reg_table             = (void *)ov5648_init_tab_2592_1944_15fps_vfifo,
		.reg_table_num_entries =
			sizeof(ov5648_init_tab_2592_1944_15fps_vfifo)
			/
			sizeof(ov5648_init_tab_2592_1944_15fps_vfifo[0]),
		.v_blanking_time_us    = 4100
	},
};

/*--------------------------------------------------------------------------*/
static int ov5648_g_VTS(struct ov_camera_module *cam_mod, u32 *vts)
{
	int ret = 0;
	u32 msb = 0;
	u32 lsb = 0;

	ret = ov_camera_module_read_reg_table(
		cam_mod,
		OV5648_TIMING_VTS_HIGH_REG,
		&msb);
	if (IS_ERR_VALUE(ret)) {
		goto err;
	}

	ret = ov_camera_module_read_reg_table(
		cam_mod,
		OV5648_TIMING_VTS_LOW_REG,
		&lsb);
	if (IS_ERR_VALUE(ret)) {
		goto err;
	}

	*vts = (msb << 8) | lsb;

	return 0;

err:
	ov_camera_module_pr_err(cam_mod,
			"failed with error (%d)\n", ret);
	return ret;
}

/*--------------------------------------------------------------------------*/

static int ov5648_auto_adjust_fps(struct ov_camera_module *cam_mod,
	u32 exp_time)
{
	int ret = 0;
	u32 vts = 0;

	if ((cam_mod->exp_config.exp_time + OV5648_INTEGRATION_TIME_MARGIN) >
		cam_mod->vts_min) {
		vts = cam_mod->exp_config.exp_time +
			OV5648_INTEGRATION_TIME_MARGIN;
	} else {
		vts = cam_mod->vts_min;
	}

	ret = ov_camera_module_write_reg(cam_mod,
		OV5648_TIMING_VTS_LOW_REG,
		vts & 0xFF);

	ret |= ov_camera_module_write_reg(cam_mod,
		OV5648_TIMING_VTS_HIGH_REG,
		(vts >> 8) & 0xFF);

	if (IS_ERR_VALUE(ret)) {
		ov_camera_module_pr_err(cam_mod,
				"failed with error (%d)\n", ret);
	} else {
		ov_camera_module_pr_debug(cam_mod,
				"vts = %d\n", vts);
	}

	return ret;
}

/*--------------------------------------------------------------------------*/
static int ov5648_write_aec(struct ov_camera_module *cam_mod)
{
	int ret      = 0;
	u32 a_gain   = 0;
	u32 exp_time = 0;

	ov_camera_module_pr_debug(cam_mod,
		"exp_time = %d, gain = %d, flash_mode = %d\n",
		cam_mod->exp_config.exp_time,
		cam_mod->exp_config.gain,
		cam_mod->exp_config.flash_mode);

	/* if the sensor is already streaming, write to shadow registers,
		if the sensor is in SW standby, write to active registers,
		if the sensor is off/registers are not writeable, do nothing */
	if ((cam_mod->state == OV_CAMERA_MODULE_SW_STANDBY) ||
		(cam_mod->state == OV_CAMERA_MODULE_STREAMING)) {
		a_gain   = cam_mod->exp_config.gain;
		exp_time = cam_mod->exp_config.exp_time << 4;

		if (cam_mod->state == OV_CAMERA_MODULE_STREAMING) {
			ret = ov_camera_module_write_reg(cam_mod,
			OV5648_AEC_GROUP_UPDATE_ADDRESS,
			OV5648_AEC_GROUP_UPDATE_START_DATA);
		}

		ret |= ov_camera_module_write_reg(cam_mod,
			OV5648_AEC_PK_LONG_GAIN_HIGH_REG,
			OV5648_FETCH_MSB_GAIN(a_gain));

		ret |= ov_camera_module_write_reg(cam_mod,
			OV5648_AEC_PK_LONG_GAIN_LOW_REG,
			OV5648_FETCH_LSB_GAIN(a_gain));

		ret = ov_camera_module_write_reg(cam_mod,
			OV5648_AEC_PK_LONG_EXPO_3RD_REG,
			OV5648_FETCH_3RD_BYTE_EXP(exp_time));

		ret |= ov_camera_module_write_reg(cam_mod,
			OV5648_AEC_PK_LONG_EXPO_2ND_REG,
			OV5648_FETCH_2ND_BYTE_EXP(exp_time));

		ret |= ov_camera_module_write_reg(cam_mod,
			OV5648_AEC_PK_LONG_EXPO_1ST_REG,
			OV5648_FETCH_1ST_BYTE_EXP(exp_time));

		if (!IS_ERR_VALUE(ret) && cam_mod->auto_adjust_fps) {
			ret = ov5648_auto_adjust_fps(cam_mod,
				cam_mod->exp_config.exp_time);
		}

		if (cam_mod->state == OV_CAMERA_MODULE_STREAMING) {
			ret = ov_camera_module_write_reg(cam_mod,
				OV5648_AEC_GROUP_UPDATE_ADDRESS,
				OV5648_AEC_GROUP_UPDATE_END_DATA);

			ret = ov_camera_module_write_reg(cam_mod,
				OV5648_AEC_GROUP_UPDATE_ADDRESS,
				OV5648_AEC_GROUP_UPDATE_END_LAUNCH);
		}
	}

	if (IS_ERR_VALUE(ret)) {
		ov_camera_module_pr_err(cam_mod,
			"failed with error (%d)\n", ret);
	}
	return ret;
}

/*--------------------------------------------------------------------------*/
static int ov5648_flip(struct ov_camera_module *cam_mod)
{
	int ret = -EAGAIN;

	if (cam_mod->state == OV_CAMERA_MODULE_SW_STANDBY &&
			cam_mod->update_config == true) {
		u32 reg_val;

		ret = ov_camera_module_read_reg(cam_mod, 1,
						OV5648_MIRROR_REG, &reg_val);

		if (!IS_ERR_VALUE(ret)) {
			/*check if mirrored already*/
			if ((reg_val & OV5648_MIRROR) == OV5648_MIRROR) {
				if (cam_mod->hflip)
					reg_val &= ~OV5648_MIRROR;
				else
					reg_val |= OV5648_MIRROR;

			} else {
				if (cam_mod->hflip)
					reg_val |= OV5648_MIRROR;
				else
					reg_val &= ~OV5648_MIRROR;
			}

				ret = ov_camera_module_write_reg(cam_mod,
							OV5648_MIRROR_REG,
							reg_val);

				if (IS_ERR_VALUE(ret))
					ov_camera_module_pr_err(cam_mod,
							"fail to update mirror reg!\n");

		} else
			ov_camera_module_pr_err(cam_mod,
							"fail to check mirror reg!\n");

		ret = ov_camera_module_read_reg(cam_mod, 1,
						OV5648_FLIP_REG, &reg_val);

		if (!IS_ERR_VALUE(ret)) {
			/*check if flipped already*/
			if ((reg_val & OV5648_FLIP) == OV5648_FLIP) {
				if (cam_mod->vflip)
					reg_val &= ~OV5648_FLIP;
				else
					reg_val |= OV5648_FLIP;

		} else {
			if (cam_mod->vflip)
				reg_val |= OV5648_FLIP;
			else
				reg_val &= ~OV5648_FLIP;
		}

		ret = ov_camera_module_write_reg(cam_mod,
						OV5648_FLIP_REG,
						reg_val);

		if (IS_ERR_VALUE(ret))
			ov_camera_module_pr_err(cam_mod,
						"fail to update flip reg!\n");

		} else
			ov_camera_module_pr_err(cam_mod,
						"fail to check flip reg!\n");

	} else
		ret = 0;


	if (IS_ERR_VALUE(ret))
		ov_camera_module_pr_err(cam_mod,
					"failed with error (%d)\n", ret);

	return ret;
}

/*--------------------------------------------------------------------------*/

static int ov5648_g_ctrl(struct ov_camera_module *cam_mod, u32 ctrl_id)
{
	int ret = 0;

	ov_camera_module_pr_debug(cam_mod, "\n");

	switch (ctrl_id) {
	case V4L2_CID_GAIN:
	case V4L2_CID_EXPOSURE:
	case V4L2_CID_FLASH_LED_MODE:
		/* nothing to be done here */
		break;
	default:
		ret = -EINVAL;
		break;
	}

	if (IS_ERR_VALUE(ret)) {
		ov_camera_module_pr_debug(cam_mod,
			"failed with error (%d)\n", ret);
	}
	return ret;
}

/*--------------------------------------------------------------------------*/
#ifdef OV5648_G_TIMINGS_QUICK
static int ov5648_filltimings(struct ov_camera_module_custom_config *custom)
{
	int i, j, win_off_v, win_off_h;
	struct ov_camera_module_config *config;
	struct ov_camera_module_timings *timings;
	struct ov_camera_module_reg *reg_table;
	int reg_table_num_entries;

	for (i = 0; i < custom->num_configs; i++) {
		config = &custom->configs[i];
		reg_table = config->reg_table;
		reg_table_num_entries = config->reg_table_num_entries;
		timings = &config->timings;

		/* The sensor can do windowing within the cropped array.
		Take this into the cropping size reported. */
		win_off_v = 0x02;
		win_off_h = 0x04;
		memset(timings, 0x00, sizeof(struct ov_camera_module_timings));
		for (j = 0; j < reg_table_num_entries; j++) {
			switch (reg_table[j].reg) {
			case OV5648_TIMING_VTS_HIGH_REG:
				timings->frame_length_lines = reg_table[j].val << 8;
				break;
			case OV5648_TIMING_VTS_LOW_REG:
				timings->frame_length_lines |= reg_table[j].val;
				break;
			case OV5648_TIMING_HTS_HIGH_REG:
				timings->line_length_pck = (reg_table[j].val << 8)&0x1f00;
				break;
			case OV5648_TIMING_HTS_LOW_REG:
				timings->line_length_pck |= reg_table[j].val;
				break;
			case OV5648_TIMING_X_INC:
				timings->binning_factor_x = ((reg_table[j].val >> 4) + 1) / 2;
				if (timings->binning_factor_x == 0)
					timings->binning_factor_x = 1;
				break;
			case OV5648_TIMING_Y_INC:
				timings->binning_factor_y = ((reg_table[j].val >> 4) + 1) / 2;
				if (timings->binning_factor_y == 0)
					timings->binning_factor_y = 1;
				break;
			case OV5648_HORIZONTAL_START_HIGH_REG:
				timings->crop_horizontal_start &= 0xff00;
				timings->crop_horizontal_start |= (reg_table[j].val << 8);
				break;
			case OV5648_HORIZONTAL_START_LOW_REG:
				timings->crop_horizontal_start &= 0xff;
				timings->crop_horizontal_start |= reg_table[j].val;
				break;
			case OV5648_VERTICAL_START_HIGH_REG:
				timings->crop_vertical_start &= 0xff00;
				timings->crop_vertical_start = reg_table[j].val << 8;
				break;
			case OV5648_VERTICAL_START_LOW_REG:
				timings->crop_vertical_start &= 0xff;
				timings->crop_vertical_start |= reg_table[j].val;
				break;
			case OV5648_HORIZONTAL_END_HIGH_REG:
				timings->crop_horizontal_end = 0xff00;
				timings->crop_horizontal_end = reg_table[j].val << 8;
				break;
			case OV5648_HORIZONTAL_END_LOW_REG:
				timings->crop_horizontal_end = 0xff;
				timings->crop_horizontal_end |= reg_table[j].val;
				break;
			case OV5648_VERTICAL_END_HIGH_REG:
				timings->crop_vertical_end &= 0xff00;
				timings->crop_vertical_end = reg_table[j].val << 8;
				break;
			case OV5648_VERTICAL_END_LOW_REG:
				timings->crop_vertical_end &= 0xff;
				timings->crop_vertical_end |= reg_table[j].val;
				break;
			case OV5648_HORIZONTAL_OUTPUT_SIZE_HIGH_REG:
				timings->sensor_output_width &= 0xff00;
				timings->sensor_output_width = (reg_table[j].val & 0x0f) << 8;
				break;
			case OV5648_HORIZONTAL_OUTPUT_SIZE_LOW_REG:
				timings->sensor_output_width &= 0xff;
				timings->sensor_output_width |= reg_table[j].val;
				break;
			case OV5648_VERTICAL_OUTPUT_SIZE_HIGH_REG:
				timings->sensor_output_height &= 0xff00;
				timings->sensor_output_height = (reg_table[j].val & 0x0f) << 8;
				break;
			case OV5648_VERTICAL_OUTPUT_SIZE_LOW_REG:
				timings->sensor_output_height &= 0xff;
				timings->sensor_output_height |= reg_table[j].val;
				break;
			case OV5648_V_WIN_OFF_HIGH_REG:
				win_off_v &= 0xff00;
				win_off_v |= (reg_table[j].val<<8);
				break;
			case OV5648_V_WIN_OFF_LOW_REG:
				win_off_v &= 0xff;
				win_off_v |= reg_table[j].val;
			case OV5648_H_WIN_OFF_HIGH_REG:
				win_off_h &= 0xff00;
				win_off_h |= (reg_table[j].val<<8);
				break;
			case OV5648_H_WIN_OFF_LOW_REG:
				win_off_h &= 0xff;
				win_off_h |= reg_table[j].val;
				break;
			}
		}

		timings->crop_vertical_start += win_off_v;
		timings->crop_vertical_end -= win_off_v;
		timings->crop_horizontal_start += win_off_h;
		timings->crop_horizontal_end -= win_off_h;

		timings->vt_pix_clk_freq_hz = config->frm_intrvl.interval.denominator
					* timings->frame_length_lines
					* timings->line_length_pck;

		timings->coarse_integration_time_min = 0;
		timings->coarse_integration_time_max_margin =
			OV5648_INTEGRATION_TIME_MARGIN;

		/* OV Sensor do not use fine integration time. */
		timings->fine_integration_time_min = 0;
		timings->fine_integration_time_max_margin = 0;
	}

	return 0;
}
static int ov5648_g_timings(struct ov_camera_module *cam_mod,
	struct ov_camera_module_timings *timings)
{
	int ret = 0;

	if (IS_ERR_OR_NULL(cam_mod->active_config))
		goto err;

	*timings = cam_mod->active_config->timings;

	ret = ov5648_g_VTS(cam_mod, &timings->frame_length_lines);
	if (IS_ERR_VALUE(ret))
		goto err;

	timings->vt_pix_clk_freq_hz = cam_mod->frm_intrvl.interval.denominator
					* timings->frame_length_lines
					* timings->line_length_pck;
	return ret;
err:
	ov_camera_module_pr_err(cam_mod,
			"failed with error (%d)\n", ret);
	return ret;
}
#else
static int ov5648_g_timings(struct ov_camera_module *cam_mod,
	struct ov_camera_module_timings *timings)
{
	int ret            = 0;
	u32 reg_val        = 0;
	u32 win_off        = 0;
	u32 pll_prediv_x2  = 0;
	u32 pll_rdiv       = 0;
	u32 pll_multiplier = 0;
	u32 sdiv0          = 0;
	u32 bit_div_x2     = 0;
	u32 sclk_div       = 0;

	if (IS_ERR_OR_NULL(cam_mod->active_config)) {
		goto err;
	}

	if (IS_ERR_VALUE(ov_camera_module_read_reg_table(
		cam_mod,
		OV5648_PLL_PREDIV_REG,
		&reg_val))) {
		goto err;
	}

	switch (reg_val & 0xf) {
	case 2:
		pll_prediv_x2 = 4;
		break;
	case 3:
		pll_prediv_x2 = 6;
		break;
	case 4:
		pll_prediv_x2 = 8;
		break;
	case 5:
		pll_prediv_x2 = 3;
		break;
	case 6:
		pll_prediv_x2 = 12;
		break;
	case 7:
		pll_prediv_x2 = 5;
		break;
	case 8:
		pll_prediv_x2 = 16;
		break;
	default:
		pll_prediv_x2 = 2;
		break;
	}
	pll_rdiv = ((reg_val >> 4) & 0x1) ? (2) : (1);

	if (IS_ERR_VALUE(ov_camera_module_read_reg_table(cam_mod, OV5648_PLL_MULTIPLIER_REG, &reg_val))) {
		goto err;
	}
	pll_multiplier = ((reg_val & 0x80) ? ((int)(reg_val / 2) * 2) : (reg_val));

	if (IS_ERR_VALUE(ov_camera_module_read_reg_table(
		cam_mod,
		OV5648_PLL_SYSDIV_REG,
		&reg_val))) {
		goto err;
	}
	sdiv0 = (((reg_val >> 4) & 0xf) ? ((reg_val >> 4) & 0xf) : (16));

	if (IS_ERR_VALUE(ov_camera_module_read_reg_table(
		cam_mod,
		OV5648_MIPI_BITMODE_REG,
		&reg_val))) {
		goto err;
	}

	switch (reg_val & 0xf) {
	case 8:
		bit_div_x2 = 4;
		break;
	case 10:
		bit_div_x2 = 5;
		break;
	default:
		bit_div_x2 = 2;
		break;
	}

	if (IS_ERR_VALUE(ov_camera_module_read_reg_table(
		cam_mod,
		OV5648_PLL_CLKDIV_REG,
		&reg_val))) {
		goto err;
	}

	switch ((reg_val >> 2) & 0x3) {
	case 0:
		sclk_div = 1;
		break;
	case 1:
		sclk_div = 2;
		break;
	case 2:
		sclk_div = 4;
		break;
	default:
		sclk_div = 1;
		break;
	}

	timings->vt_pix_clk_freq_hz =
			((OV5648_EXT_CLK * 2) / pll_prediv_x2 * pll_multiplier) * 2 /
				sdiv0 /
				pll_rdiv /
				bit_div_x2 /
				sclk_div;

	/*VTS*/
	ret = ov5648_g_VTS(cam_mod, &timings->frame_length_lines);
	if (IS_ERR_VALUE(ret)) {
		goto err;
	}

	/*HTS*/
	if (IS_ERR_VALUE(ov_camera_module_read_reg_table(
		cam_mod,
		OV5648_TIMING_HTS_HIGH_REG,
		&reg_val))) {
		goto err;
	}
	timings->line_length_pck = reg_val << 8;

	if (IS_ERR_VALUE(ov_camera_module_read_reg_table(
		cam_mod,
		OV5648_TIMING_HTS_LOW_REG,
		&reg_val))) {
		goto err;
	}
	timings->line_length_pck |= reg_val;

	timings->coarse_integration_time_min        = 1;
	timings->coarse_integration_time_max_margin = OV5648_INTEGRATION_TIME_MARGIN;

	/* OV Sensor do not use fine integration time. */
	timings->fine_integration_time_min          = 0;
	timings->fine_integration_time_max_margin   = 0;

	if (IS_ERR_VALUE(ov_camera_module_read_reg_table(
		cam_mod,
		OV5648_TIMING_X_INC,
		&reg_val))) {
		goto err;
	}
	timings->binning_factor_x = ((reg_val >> 4) + 1) / 2;

	if (IS_ERR_VALUE(ov_camera_module_read_reg_table(
		cam_mod,
		OV5648_TIMING_Y_INC,
		&reg_val))) {
		goto err;
	}
	timings->binning_factor_y = ((reg_val >> 4) + 1) / 2;

	/*printk("bella_factor_x=[%d],y=[%d]\n", timings->binning_factor_x, timings->binning_factor_y);*/

	/* Get the cropping and output resolution to ISP for this mode. */
	if (IS_ERR_VALUE(ov_camera_module_read_reg_table(
		cam_mod,
		OV5648_HORIZONTAL_START_HIGH_REG,
		&reg_val))) {
		goto err;
	}
	timings->crop_horizontal_start = reg_val << 8;

	if (IS_ERR_VALUE(ov_camera_module_read_reg_table(
		cam_mod,
		OV5648_HORIZONTAL_START_LOW_REG,
		&reg_val))) {
		goto err;
	}
	timings->crop_horizontal_start |= reg_val;

	if (IS_ERR_VALUE(ov_camera_module_read_reg_table(
		cam_mod,
		OV5648_VERTICAL_START_HIGH_REG,
		&reg_val))) {
		goto err;
	}
	timings->crop_vertical_start = reg_val << 8;

	if (IS_ERR_VALUE(ov_camera_module_read_reg_table(
		cam_mod,
		OV5648_VERTICAL_START_LOW_REG,
		&reg_val))) {
		goto err;
	}
	timings->crop_vertical_start |= reg_val;

	if (IS_ERR_VALUE(ov_camera_module_read_reg_table(
		cam_mod,
		OV5648_HORIZONTAL_END_HIGH_REG,
		&reg_val))) {
		goto err;
	}
	timings->crop_horizontal_end = reg_val << 8;

	if (IS_ERR_VALUE(ov_camera_module_read_reg_table(
		cam_mod,
		OV5648_HORIZONTAL_END_LOW_REG,
		&reg_val))) {
		goto err;
	}
	timings->crop_horizontal_end |= reg_val;

	if (IS_ERR_VALUE(ov_camera_module_read_reg_table(
		cam_mod,
		OV5648_VERTICAL_END_HIGH_REG,
		&reg_val))) {
		goto err;
	}
	timings->crop_vertical_end = reg_val << 8;

	if (IS_ERR_VALUE(ov_camera_module_read_reg_table(
		cam_mod,
		OV5648_VERTICAL_END_LOW_REG,
		&reg_val))) {
		goto err;
	}
	timings->crop_vertical_end |= reg_val;

	/* The sensor can do windowing within the cropped array.
	Take this into the cropping size reported. */
	if (IS_ERR_VALUE(ov_camera_module_read_reg_table(
		cam_mod,
		OV5648_H_WIN_OFF_HIGH_REG,
		&reg_val))) {
		goto err;
	}
	win_off = (reg_val & 0xf) << 8;

	if (IS_ERR_VALUE(ov_camera_module_read_reg_table(
		cam_mod,
		OV5648_H_WIN_OFF_LOW_REG,
		&reg_val))) {
		goto err;
	}
	win_off |= (reg_val & 0xff);

	timings->crop_horizontal_start += win_off;
	timings->crop_horizontal_end   -= win_off;

	if (IS_ERR_VALUE(ov_camera_module_read_reg_table(
		cam_mod,
		OV5648_V_WIN_OFF_HIGH_REG,
		&reg_val))) {
		goto err;
	}
	win_off = (reg_val & 0xf) << 8;

	if (IS_ERR_VALUE(ov_camera_module_read_reg_table(
		cam_mod,
		OV5648_V_WIN_OFF_LOW_REG,
		&reg_val))) {
		goto err;
	}
	win_off |= (reg_val & 0xff);

	timings->crop_vertical_start += win_off;
	timings->crop_vertical_end   -= win_off;

	if (IS_ERR_VALUE(ov_camera_module_read_reg_table(
		cam_mod,
		OV5648_HORIZONTAL_OUTPUT_SIZE_HIGH_REG,
		&reg_val))) {
		goto err;
	}
	timings->sensor_output_width = reg_val << 8;

	if (IS_ERR_VALUE(ov_camera_module_read_reg_table(
		cam_mod,
		OV5648_HORIZONTAL_OUTPUT_SIZE_LOW_REG,
		&reg_val))) {
		goto err;
	}
	timings->sensor_output_width |= reg_val;

	if (IS_ERR_VALUE(ov_camera_module_read_reg_table(
		cam_mod,
		OV5648_VERTICAL_OUTPUT_SIZE_HIGH_REG,
		&reg_val))) {
		goto err;
	}
	timings->sensor_output_height = reg_val << 8;

	if (IS_ERR_VALUE(ov_camera_module_read_reg_table(
		cam_mod,
		OV5648_VERTICAL_OUTPUT_SIZE_LOW_REG,
		&reg_val))) {
		goto err;
	}
	timings->sensor_output_height |= reg_val;

	return ret;

err:
	ov_camera_module_pr_err(cam_mod,
			"failed with error (%d)\n", ret);
	return ret;
}
#endif
/*--------------------------------------------------------------------------*/

static int ov5648_s_ctrl(struct ov_camera_module *cam_mod, u32 ctrl_id)
{
	int ret = 0;

	ov_camera_module_pr_debug(cam_mod, "\n");

	switch (ctrl_id) {
	case V4L2_CID_GAIN:
	case V4L2_CID_EXPOSURE:
		ret = ov5648_write_aec(cam_mod);
		break;
	case V4L2_CID_FLASH_LED_MODE:
		/* nothing to be done here */
		break;
	case V4L2_CID_HFLIP:
	case V4L2_CID_VFLIP:
		ret = ov5648_flip(cam_mod);
		break;
	default:
		ret = -EINVAL;
		break;
	}

	if (IS_ERR_VALUE(ret)) {
		ov_camera_module_pr_debug(cam_mod,
			"failed with error (%d) 0x%x\n", ret, ctrl_id);
	}
	return ret;
}

/*--------------------------------------------------------------------------*/

static int ov5648_s_ext_ctrls(struct ov_camera_module *cam_mod,
				 struct ov_camera_module_ext_ctrls *ctrls)
{
	int ret = 0;

	/* Handles only exposure and gain together special case. */
	if (ctrls->count == 1) {
		ret = ov5648_s_ctrl(cam_mod, ctrls->ctrls[0].id);
	} else if (ctrls->count == 2 &&
		((ctrls->ctrls[0].id == V4L2_CID_GAIN &&
		ctrls->ctrls[1].id == V4L2_CID_EXPOSURE) ||
		(ctrls->ctrls[1].id == V4L2_CID_GAIN &&
		ctrls->ctrls[0].id == V4L2_CID_EXPOSURE))) {
		ret = ov5648_write_aec(cam_mod);
	} else {
		ret = -EINVAL;
	}

	if (IS_ERR_VALUE(ret)) {
		ov_camera_module_pr_debug(cam_mod,
			"failed with error (%d)\n", ret);
	}
	return ret;
}

/*--------------------------------------------------------------------------*/
/* index: index of otp group. (1, 2, 3)
 * return: 0,
 */
static int read_otp(struct ov_camera_module *cam_mod,
	    int index)
{
	int i;
	u32 temp;
	/* read otp into buffer */
	if (index == 1) {
		/* read otp --Bank 0 */
		ov_camera_module_write_reg(cam_mod, 0x3d84, 0xc0);
		ov_camera_module_write_reg(cam_mod, 0x3d85, 0x00);
		ov_camera_module_write_reg(cam_mod, 0x3d86, 0x0f);
		ov_camera_module_write_reg(cam_mod, 0x3d81, 0x01);
		mdelay(5);
		ov_camera_module_read_reg(cam_mod, 1,
			0x3d05, &((*otp_ptr).module_integrator_id));
		(*otp_ptr).module_integrator_id =
			(*otp_ptr).module_integrator_id & 0x7f;
		ov_camera_module_read_reg(cam_mod, 1,
			0x3d06, &((*otp_ptr).lens_id));
		ov_camera_module_read_reg(cam_mod, 1, 0x3d0b, &temp);
		ov_camera_module_read_reg(cam_mod, 1,
			0x3d07, &((*otp_ptr).rg_ratio));
		(*otp_ptr).rg_ratio =
			((*otp_ptr).rg_ratio<<2) + ((temp>>6) & 0x03);
		ov_camera_module_read_reg(cam_mod, 1,
			0x3d08, &((*otp_ptr).bg_ratio));
		(*otp_ptr).bg_ratio =
			((*otp_ptr).bg_ratio<<2) + ((temp>>4) & 0x03);
		ov_camera_module_read_reg(cam_mod, 1,
			0x3d0c, &((*otp_ptr).light_rg));
		(*otp_ptr).light_rg =
			((*otp_ptr).light_rg<<2) + ((temp>>2) & 0x03);
		ov_camera_module_read_reg(cam_mod, 1,
			0x3d0d, &((*otp_ptr).light_bg));
		(*otp_ptr).light_bg =
			((*otp_ptr).light_bg<<2) + (temp & 0x03);
		ov_camera_module_read_reg(cam_mod, 1,
			0x3d09, &((*otp_ptr).user_data[0]));
		ov_camera_module_read_reg(cam_mod, 1,
			0x3d0a, &((*otp_ptr).user_data[1]));
	} else if (index == 2) {
		/* read otp --Bank 0 */
		ov_camera_module_write_reg(cam_mod, 0x3d84, 0xc0);
		ov_camera_module_write_reg(cam_mod, 0x3d85, 0x00);
		ov_camera_module_write_reg(cam_mod, 0x3d86, 0x0f);
		ov_camera_module_write_reg(cam_mod, 0x3d81, 0x01);
		mdelay(5);
		ov_camera_module_read_reg(cam_mod, 1,
			0x3d0e, &((*otp_ptr).module_integrator_id));
		(*otp_ptr).module_integrator_id =
			(*otp_ptr).module_integrator_id & 0x7f;
		ov_camera_module_read_reg(cam_mod, 1,
			0x3d0f, &((*otp_ptr).lens_id));
		/* read otp --Bank 1 */
		ov_camera_module_write_reg(cam_mod, 0x3d84, 0xc0);
		ov_camera_module_write_reg(cam_mod, 0x3d85, 0x10);
		ov_camera_module_write_reg(cam_mod, 0x3d86, 0x1f);
		ov_camera_module_write_reg(cam_mod, 0x3d81, 0x01);
		mdelay(5);
		ov_camera_module_read_reg(cam_mod, 1, 0x3d04, &temp);
		ov_camera_module_read_reg(cam_mod, 1,
			0x3d00, &((*otp_ptr).rg_ratio));
		(*otp_ptr).rg_ratio =
			((*otp_ptr).rg_ratio<<2) + ((temp>>6) & 0x03);
		ov_camera_module_read_reg(cam_mod, 1,
			0x3d01, &((*otp_ptr).bg_ratio));
		(*otp_ptr).bg_ratio =
			((*otp_ptr).bg_ratio<<2) + ((temp>>4) & 0x03);
		ov_camera_module_read_reg(cam_mod, 1,
			0x3d05, &((*otp_ptr).light_rg));
		(*otp_ptr).light_rg =
			((*otp_ptr).light_rg<<2) + ((temp>>2) & 0x03);
		ov_camera_module_read_reg(cam_mod, 1,
			0x3d06, &((*otp_ptr).light_bg));
		(*otp_ptr).light_bg =
			((*otp_ptr).light_bg<<2) + (temp & 0x03);
		ov_camera_module_read_reg(cam_mod, 1,
			0x3d02, &((*otp_ptr).user_data[0]));
		ov_camera_module_read_reg(cam_mod, 1,
			0x3d03, &((*otp_ptr).user_data[1]));
	} else if (index == 3) {
		/* read otp --Bank 1 */
		ov_camera_module_write_reg(cam_mod, 0x3d84, 0xc0);
		ov_camera_module_write_reg(cam_mod, 0x3d85, 0x10);
		ov_camera_module_write_reg(cam_mod, 0x3d86, 0x1f);
		ov_camera_module_write_reg(cam_mod, 0x3d81, 0x01);
		mdelay(5);
		ov_camera_module_read_reg(cam_mod, 1,
			0x3d07, &((*otp_ptr).module_integrator_id));
		(*otp_ptr).module_integrator_id =
			(*otp_ptr).module_integrator_id & 0x7f;
		ov_camera_module_read_reg(cam_mod, 1,
			0x3d08, &((*otp_ptr).lens_id));
		ov_camera_module_read_reg(cam_mod, 1, 0x3d0d, &temp);
		ov_camera_module_read_reg(cam_mod, 1,
			0x3d09, &((*otp_ptr).rg_ratio));
		(*otp_ptr).rg_ratio =
			((*otp_ptr).rg_ratio<<2) + ((temp>>6) & 0x03);
		ov_camera_module_read_reg(cam_mod, 1,
			0x3d0a, &((*otp_ptr).bg_ratio));
		(*otp_ptr).bg_ratio =
			((*otp_ptr).bg_ratio<<2) + ((temp>>4) & 0x03);
		ov_camera_module_read_reg(cam_mod, 1,
			0x3d0e, &((*otp_ptr).light_rg));
		(*otp_ptr).light_rg =
			((*otp_ptr).light_rg<<2) + ((temp>>2) & 0x03);
		ov_camera_module_read_reg(cam_mod, 1,
			0x3d0f, &((*otp_ptr).light_bg));
		(*otp_ptr).light_bg =
			((*otp_ptr).light_bg<<2) + (temp & 0x03);
		ov_camera_module_read_reg(cam_mod, 1,
			0x3d0b, &((*otp_ptr).user_data[0]));
		ov_camera_module_read_reg(cam_mod, 1,
			0x3d0c, &((*otp_ptr).user_data[1]));
	}
	/* clear otp buffer */
	for (i = 0; i < 16; i++)
		ov_camera_module_write_reg(cam_mod, 0x3d00 + i, 0x00);

	return 0;
}

/*
 *Camera driver need to load AWB calibration data
 *stored in OTP and write to gain registers after
 *initialization of register settings.
 * index: index of otp group. (1, 2, 3)
 * return: 0, group index is empty
 *		1, group index has invalid data
 *		2, group index has valid data
 */
static int check_otp(struct ov_camera_module *cam_mod, int index)
{
	int i;
	int flag = 0, rg = 0, bg = 0;
	if (index == 1) {
		/* read otp --Bank 0 */
		ov_camera_module_write_reg(cam_mod, 0x3d84, 0xc0);
		ov_camera_module_write_reg(cam_mod, 0x3d85, 0x00);
		ov_camera_module_write_reg(cam_mod, 0x3d86, 0x0f);
		ov_camera_module_write_reg(cam_mod, 0x3d81, 0x01);
		mdelay(5);
		ov_camera_module_read_reg(cam_mod, 1, 0x3d05, &flag);
		ov_camera_module_read_reg(cam_mod, 1, 0x3d07, &rg);
		ov_camera_module_read_reg(cam_mod, 1, 0x3d08, &bg);
	} else if (index == 2) {
		/* read otp --Bank 0 */
		ov_camera_module_write_reg(cam_mod, 0x3d84, 0xc0);
		ov_camera_module_write_reg(cam_mod, 0x3d85, 0x00);
		ov_camera_module_write_reg(cam_mod, 0x3d86, 0x0f);
		ov_camera_module_write_reg(cam_mod, 0x3d81, 0x01);
		mdelay(5);
		ov_camera_module_read_reg(cam_mod, 1, 0x3d0e, &flag);

		/* read otp --Bank 1 */
		ov_camera_module_write_reg(cam_mod, 0x3d84, 0xc0);
		ov_camera_module_write_reg(cam_mod, 0x3d85, 0x10);
		ov_camera_module_write_reg(cam_mod, 0x3d86, 0x1f);
		ov_camera_module_write_reg(cam_mod, 0x3d81, 0x01);
		mdelay(5);
		ov_camera_module_read_reg(cam_mod, 1, 0x3d00, &rg);
		ov_camera_module_read_reg(cam_mod, 1, 0x3d01, &bg);
	} else if (index == 3) {
		/* read otp --Bank 1 */
		ov_camera_module_write_reg(cam_mod, 0x3d84, 0xc0);
		ov_camera_module_write_reg(cam_mod, 0x3d85, 0x10);
		ov_camera_module_write_reg(cam_mod, 0x3d86, 0x1f);
		ov_camera_module_write_reg(cam_mod, 0x3d81, 0x01);
		mdelay(5);
		ov_camera_module_read_reg(cam_mod, 1, 0x3d07, &flag);
		ov_camera_module_read_reg(cam_mod, 1, 0x3d09, &rg);
		ov_camera_module_read_reg(cam_mod, 1, 0x3d0a, &bg);
	}

	flag = flag & 0x80;

	/* clear otp buffer */
	for (i = 0; i < 16; i++)
		ov_camera_module_write_reg(cam_mod, 0x3d00 + i, 0x00);

	if (flag) {
		return 1;
	} else {
		if (rg == 0 && bg == 0)
			return 0;
		else
			return 2;
	}

}

/* R_gain, sensor red gain of AWB, 0x400 =1
 * G_gain, sensor green gain of AWB, 0x400 =1
 * B_gain, sensor blue gain of AWB, 0x400 =1
 * return 0;
 */
static int ov5648_update_awb_gain(struct ov_camera_module *cam_mod)
{
	int R_gain = otp_ptr->R_gain;
	int G_gain = otp_ptr->G_gain;
	int B_gain = otp_ptr->B_gain;
	if (R_gain > 0x400) {
		ov_camera_module_write_reg(cam_mod, 0x5186, R_gain>>8);
		ov_camera_module_write_reg(cam_mod, 0x5187, R_gain & 0x00ff);
	}
	if (G_gain > 0x400) {
		ov_camera_module_write_reg(cam_mod, 0x5188, G_gain>>8);
		ov_camera_module_write_reg(cam_mod, 0x5189, G_gain & 0x00ff);
	}
	if (B_gain > 0x400) {
		ov_camera_module_write_reg(cam_mod, 0x518a, B_gain>>8);
		ov_camera_module_write_reg(cam_mod, 0x518b, B_gain & 0x00ff);
	}

	return 0;
}

static int ov5648_otp_read(struct ov_camera_module *cam_mod)
{
	int ret = 0;
	int temp = 0;
	int i, otp_index;
	u16 rg = 1, bg = 1;
	int R_gain, G_gain, B_gain, G_gain_R, G_gain_B;
	struct i2c_client *client = v4l2_get_subdevdata(&cam_mod->sd);

	ov_camera_module_pr_debug(cam_mod, "\n");

	if (otp_ptr != NULL) {
		ov_camera_module_pr_debug(cam_mod, "OTP data loaded already\n");
		return 0;
	} else {
		otp_ptr = kzalloc(sizeof(*otp_ptr), GFP_KERNEL);
		if (!otp_ptr) {
			ov_camera_module_pr_err(cam_mod, "otp alloc fail!\n");
			return -ENOMEM;
		}
	}

	ov_camera_module_write_reg(cam_mod, 0x0100, 1);

	/* R/G and B/G of current camera module is read out from sensor OTP
	 * check first OTP with valid data
	 */
	for (i = 1; i <= 3; i++) {
		temp = check_otp(cam_mod, i);
		if (temp == 2) {
			otp_index = i;
			break;
		}
	}
	if (i > 3) {
		/* no valid wb OTP data */
		otp_ptr->otp_en = 0;
		return 1;
	}

	read_otp(cam_mod, otp_index);

	if (otp_ptr->light_rg == 0) {
		/* no light source information in OTP */
		rg = otp_ptr->rg_ratio;
	} else {
		/* light source information found in OTP */
		rg = otp_ptr->rg_ratio * (otp_ptr->light_rg + 512) / 1024;
	}
	if (otp_ptr->light_bg == 0) {
		/* no light source information in OTP */
		bg = otp_ptr->bg_ratio;
	} else {
		/* light source information found in OTP */
		bg = otp_ptr->bg_ratio * (otp_ptr->light_bg + 512) / 1024;
	}

	if (rg == 0)
		rg = 1;
	if (bg == 0)
		bg = 1;

	/*calculate G gain
	 *0x400 = 1x gain
	 */
	if (bg < BG_Ratio_Typical) {
		if (rg < RG_Ratio_Typical) {
			/* current_otp.bg_ratio < BG_Ratio_typical &&
			 * current_otp.rg_ratio < RG_Ratio_typical
			 */
			G_gain = 0x400;
			B_gain = 0x400 * BG_Ratio_Typical / bg;
			R_gain = 0x400 * RG_Ratio_Typical / rg;
		} else {
			/* current_otp.bg_ratio < BG_Ratio_typical &&
			 * current_otp.rg_ratio >= RG_Ratio_typical
			 */
			R_gain = 0x400;
			G_gain = 0x400 * rg / RG_Ratio_Typical;
			B_gain = G_gain * BG_Ratio_Typical / bg;
		}
	} else {
		if (rg < RG_Ratio_Typical) {
			/* current_otp.bg_ratio >= BG_Ratio_typical &&
			 * current_otp.rg_ratio < RG_Ratio_typical
			 */
			B_gain = 0x400;
			G_gain = 0x400 * bg / BG_Ratio_Typical;
			R_gain = G_gain * RG_Ratio_Typical / rg;
		} else {
			/* current_otp.bg_ratio >= BG_Ratio_typical &&
			 * current_otp.rg_ratio >= RG_Ratio_typical
			 */
			G_gain_B = 0x400 * bg / BG_Ratio_Typical;
			G_gain_R = 0x400 * rg / RG_Ratio_Typical;
			if (G_gain_B > G_gain_R) {
				B_gain = 0x400;
				G_gain = G_gain_B;
				R_gain = G_gain * RG_Ratio_Typical / rg;
			} else {
				R_gain = 0x400;
				G_gain = G_gain_R;
				B_gain = G_gain * BG_Ratio_Typical / bg;
			}
		}
	}

	otp_ptr->R_gain = R_gain;
	otp_ptr->G_gain = G_gain;
	otp_ptr->B_gain = B_gain;

	ov_camera_module_write_reg(cam_mod, 0x0100, 0);

	otp_ptr->otp_en = 1;
	dev_info(&client->dev, "get otp data success\n");
	return ret;
}


/*--------------------------------------------------------------------------*/

static int ov5648_start_streaming(struct ov_camera_module *cam_mod)
{
	int ret = 0;

	ov_camera_module_pr_err(cam_mod, "active config=%s\n", cam_mod->active_config->name);

	/*apply otp data*/
	if (otp_ptr != NULL && otp_ptr->otp_en == 1) {
		ov_camera_module_pr_debug(cam_mod,
					"apply otp data for ov5648...\n");
		ov5648_update_awb_gain(cam_mod);
	}

	ret = ov5648_g_VTS(cam_mod, &cam_mod->vts_min);
	if (IS_ERR_VALUE(ret)) {
		goto err;
	}

	ret = ov5648_write_aec(cam_mod);
	if (IS_ERR_VALUE(ret)) {
		goto err;
	}

	ret = ov5648_flip(cam_mod);
	if (IS_ERR_VALUE(ret))
		goto err;


	if (IS_ERR_VALUE(ov_camera_module_write_reg(cam_mod, 0x301a, 0xf0)))
		goto err;

	return 0;

err:
	ov_camera_module_pr_err(cam_mod, "failed with error (%d)\n",
		ret);
	return ret;
}

/*--------------------------------------------------------------------------*/

static int ov5648_stop_streaming(struct ov_camera_module *cam_mod)
{
	int ret = 0;

	ov_camera_module_pr_debug(cam_mod, "\n");

	/*ret = ov_camera_module_write_reg(cam_mod, 0x0100, 0);*/
	ret = ov_camera_module_write_reg(cam_mod, 0x301a, 0xf1);
	if (IS_ERR_VALUE(ret)) {
		goto err;
	}
	return 0;

err:
	ov_camera_module_pr_err(cam_mod, "failed with error (%d)\n", ret);
	return ret;
}

/*--------------------------------------------------------------------------*/

static int ov5648_check_camera_id(struct ov_camera_module *cam_mod)
{
	u32 pidh, pidl;
	int ret = 0;

	ov_camera_module_pr_debug(cam_mod, "\n");

	ret |= ov_camera_module_read_reg(cam_mod, 1, OV5648_PIDH_ADDR, &pidh);
	ret |= ov_camera_module_read_reg(cam_mod, 1, OV5648_PIDL_ADDR, &pidl);
	if (IS_ERR_VALUE(ret)) {
		ov_camera_module_pr_err(cam_mod,
			"register read failed, camera module powered off?\n");
		goto err;
	}

	if ((pidh == OV5648_PIDH_MAGIC) && (pidl == OV5648_PIDL_MAGIC)) {
		ov_camera_module_pr_debug(cam_mod,
				"successfully detected camera ID 0x%02x%02x\n",
			pidh, pidl);
	} else {
		ov_camera_module_pr_err(cam_mod,
				"wrong camera ID, expected 0x%02x%02x, detected 0x%02x%02x\n",
			OV5648_PIDH_MAGIC, OV5648_PIDL_MAGIC, pidh, pidl);
		ret = -EINVAL;
		goto err;
	}

	return 0;

err:
	ov_camera_module_pr_err(cam_mod, "failed with error (%d)\n", ret);
	return ret;
}

/* ======================================================================== */
/* This part is platform dependent */
/* ======================================================================== */

static struct v4l2_subdev_core_ops ov5648_camera_module_core_ops = {
	.g_ctrl              = ov_camera_module_g_ctrl,
	.s_ctrl              = ov_camera_module_s_ctrl,
	.s_ext_ctrls         = ov_camera_module_s_ext_ctrls,
	.s_power             = ov_camera_module_s_power,
	.ioctl               = ov_camera_module_ioctl
};

static struct v4l2_subdev_video_ops ov5648_camera_module_video_ops = {
	.enum_frameintervals = ov_camera_module_enum_frameintervals,
	.s_mbus_fmt          = ov_camera_module_s_fmt,
	.g_mbus_fmt          = ov_camera_module_g_fmt,
	.try_mbus_fmt        = ov_camera_module_try_fmt,
	.s_frame_interval    = ov_camera_module_s_frame_interval,
	.s_stream            = ov_camera_module_s_stream
};

static struct v4l2_subdev_ops ov5648_camera_module_ops = {
	.core                = &ov5648_camera_module_core_ops,
	.video               = &ov5648_camera_module_video_ops
};

static struct ov_camera_module_custom_config ov5648_custom_config = {
	.start_streaming    = ov5648_start_streaming,
	.stop_streaming     = ov5648_stop_streaming,
	.s_ctrl             = ov5648_s_ctrl,
	.s_ext_ctrls        = ov5648_s_ext_ctrls,
	.g_ctrl             = ov5648_g_ctrl,
	.g_timings          = ov5648_g_timings,
	.check_camera_id    = ov5648_check_camera_id,
	/*.read_otp = ov5648_otp_read,*/
	.configs            = ov5648_configs,
	.num_configs        = sizeof(ov5648_configs) / sizeof(ov5648_configs[0]),
	.power_up_delays_ms = {5, 20, 0}
};

static int __init ov5648_probe(
	struct i2c_client *client,
	const struct i2c_device_id *id)
{
	int ret = 0;

	dev_info(&client->dev, "probing...\n");
#ifdef OV5648_G_TIMINGS_QUICK
	ov5648_filltimings(&ov5648_custom_config);
#endif
	v4l2_i2c_subdev_init(&ov5648.sd, client, &ov5648_camera_module_ops);

	ret = ov_camera_module_init(&ov5648,
			&ov5648_custom_config);
	if (IS_ERR_VALUE(ret)) {
		goto err;
	}

	ret = ov_camera_module_s_power(&ov5648.sd, 1);
	if (!IS_ERR_VALUE(ret)) {
		ret = ov5648_otp_read(&ov5648);
		if (IS_ERR_VALUE(ret)) {
			dev_warn(&client->dev, "ov5648 otp read failed with error (%d)\n", ret);
		}
	}
	ov_camera_module_s_power(&ov5648.sd, 0);

	dev_info(&client->dev, "probing successful\n");
	return 0;

err:
	dev_err(&client->dev, "probing failed with error (%d)\n", ret);
	ov_camera_module_release(&ov5648);	
	return ret;
}

/* ======================================================================== */

static int __exit ov5648_remove(
	struct i2c_client *client)
{
	struct ov_camera_module *cam_mod = i2c_get_clientdata(client);

	dev_info(&client->dev, "removing device...\n");

	if (!client->adapter) {
		return -ENODEV;	/* our client isn't attached */
	}

	ov_camera_module_release(cam_mod);

	if (otp_ptr != NULL)
		kfree(otp_ptr);

	dev_info(&client->dev, "removed\n");

	return 0;
}

static const struct i2c_device_id ov5648_id[] = {
	{ OV5648_DRIVER_NAME, 0 },
	{ }
}; 

static struct of_device_id ov5648_of_match[] = {
	{.compatible = "omnivision," OV5648_DRIVER_NAME "-v4l2-i2c-subdev",},
	{},
};

MODULE_DEVICE_TABLE(i2c, ov5648_id);

static struct i2c_driver ov5648_i2c_driver = {
	.driver = {
		.name           = OV5648_DRIVER_NAME,
		.owner          = THIS_MODULE,
		.of_match_table = ov5648_of_match
	},
	.probe              = ov5648_probe,
	.remove             = __exit_p(ov5648_remove),
	.id_table           = ov5648_id,
};

module_i2c_driver(ov5648_i2c_driver);

MODULE_DESCRIPTION("SoC Camera driver for ov5648");
MODULE_AUTHOR("Kunkka Lu");
MODULE_LICENSE("GPL");

